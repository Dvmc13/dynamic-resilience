spring:
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
  cloud:
    bus:
      enabled: true
    inetutils:
      preferredNetworks: 127.0.0.1
      ignoredInterfaces: eth0
  application:
    name: global-config

server:
  port: 8080

management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      show-details: always
    refresh:
      enabled: true
    prometheus:
      enabled: true

# Configuración de Resilience4j (valores por defecto; los microservicios pueden ser refrescados para aplicar overrides dinámicos)
resilience4j:
  circuitbreaker:
    instances:
      catalog-service:
        slidingWindowType: COUNT_BASED
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        slowCallRateThreshold: 50
        slowCallDurationThreshold: 2000ms
        permittedNumberOfCallsInHalfOpenState: 3
        waitDurationInOpenState: 10000ms
        metrics:
          enabled: true
        # Este campo se puede actualizar dinámicamente mediante el bus-refresh
        forcedState: ${CATALOG_SERVICE_CIRCUIT_FORCED_STATE:}
      order-service:
        slidingWindowType: COUNT_BASED
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        slowCallRateThreshold: 50
        slowCallDurationThreshold: 2000ms
        permittedNumberOfCallsInHalfOpenState: 3
        waitDurationInOpenState: 10000ms
        metrics:
          enabled: true
        forcedState: ${ORDER_SERVICE_CIRCUIT_FORCED_STATE:}
  retry:
    instances:
      order-service:
        maxAttempts: ${ORDER_SERVICE_RETRY_MAX_ATTEMPTS:3}
        waitDuration: ${ORDER_SERVICE_RETRY_WAIT_DURATION:500ms}
        metrics:
          enabled: true
  bulkhead:
    instances:
      "*":
        metrics:
          enabled: true
  ratelimiter:
    instances:
      "*":
        metrics:
          enabled: true

logging:
  level:
    root: INFO
    com.example.resilience_library: DEBUG
