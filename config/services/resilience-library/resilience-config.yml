spring:
  application:
    name: resilience-library
  cloud:
    gateway:
      httpclient:
        response-timeout: 5s
        connect-timeout: 2s
      metrics:
        enabled: true
      actuator:
        verbose:
          enabled: true
  main:
    web-application-type: reactive

resilience:
  gateway:
    enabled: true
    services:
      frontend:
        host: ${FRONTEND_HOST:frontend}
        port: ${FRONTEND_PORT:8080}
        circuitBreaker:
          enabled: true
          fallbackUri: forward:/fallback/frontend
          slidingWindowSize: 100
          failureRateThreshold: 50
          waitDurationInOpenState: 30
          permittedCallsInHalfOpen: 5
          automaticTransitionFromOpenToHalfOpenEnabled: true
          minimumNumberOfCalls: 10
        retry:
          enabled: true
          maxAttempts: 3
          waitDuration: 750ms
          enableExponentialBackoff: true
          exponentialBackoffMultiplier: 2
          fallbackUri: forward:/fallback/retry-exhausted
        rateLimiter:
          enabled: true
          limitForPeriod: 100
          limitRefreshPeriod: 1s
          timeoutDuration: 0
          fallbackUri: forward:/fallback/rate-limited
        bulkhead:
          enabled: true
          maxConcurrentCalls: 200
          maxWaitDuration: 50ms
          fallbackUri: forward:/fallback/bulkhead-full
    response-templates:
      circuit-open: |
        {
          "status": "SERVICE_UNAVAILABLE",
          "message": "El servicio está temporalmente no disponible. Por favor intente más tarde.",
          "timestamp": "${timestamp}",
          "path": "${path}"
        }
      rate-limited: |
        {
          "status": "TOO_MANY_REQUESTS",
          "message": "Has excedido el límite de solicitudes. Por favor espera e intenta nuevamente.",
          "resetAt": "${resetTime}",
          "path": "${path}"
        }

resilience4j:
  circuitbreaker:
    instances:
      gateway-core:
        base-config: default
        wait-duration-in-open-state: 45s
        failure-rate-threshold: 60
        event-consumer-buffer-size: 100
      frontend-service:
        base-config: default
        wait-duration-in-open-state: 30s
        failure-rate-threshold: 50
        sliding-window-size: 100

  retry:
    instances:
      gateway-retry:
        max-attempts: 3
        wait-duration: 750ms
        retry-exceptions:
          - org.springframework.web.reactive.function.client.WebClientResponseException
          - java.io.IOException
          - java.util.concurrent.TimeoutException

  bulkhead:
    instances:
      gateway-requests:
        max-concurrent-calls: 200
        max-wait-duration: 50ms

  timelimiter:
    instances:
      gateway-timeout:
        timeout-duration: 5s
        cancel-running-future: true

  ratelimiter:
    instances:
      gateway-limiter:
        limit-for-period: 100
        limit-refresh-period: 1s
        timeout-duration: 0
        register-health-indicator: true

management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    health:
      show-details: always
      probes:
        enabled: true
    gateway:
      enabled: true
  metrics:
    tags:
      application: resilience-library
    export:
      prometheus:
        enabled: true
  health:
    circuitbreakers:
      enabled: true
    ratelimiters:
      enabled: true

alerting:
  enabled: true
  webhook-url: ${RESILIENCE_WEBHOOK:http://alertmanager:9093/api/v1/alerts}
  threshold:
    circuit-breaker-open: 60000
    high-failure-rate: 70
    high-latency-ms: 2000

spring:
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}

logging:
  level:
    org.springframework.cloud.gateway: INFO
    org.springframework.cloud.gateway.filter: INFO
    org.springframework.cloud.gateway.route: INFO
    org.springframework.web.reactive: INFO
    io.github.resilience4j: INFO
